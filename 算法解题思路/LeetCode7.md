让我帮你解析 LeetCode 7号问题（Reverse Integer），并提供 Java 实现。

整数翻转/反转

### 问题解析
1. **目标**：
    - 输入一个 32 位有符号整数 x
    - 将其数字部分反转（例如 123 → 321）
    - 检查反转后的结果是否在 32 位有符号整数范围内 [-2³¹, 2³¹-1]，即 [-2147483648, 2147483647]
    - 如果超出范围，返回 0

2. **关键点**：
    - 处理正负号：反转时只处理数字部分，保留符号
    - 处理溢出：在反转过程中需要检查是否会超出整数范围
    - 处理末尾为 0 的情况：如 120 → 21（自动去掉前导零）

3. **算法思路**：
    - 使用数学方法，通过取模和除法逐位反转数字
    - 用 long 类型临时存储结果，避免溢出后再检查
    - 最后验证结果是否在 32 位整数范围内

### Java 实现
```java
class Solution {
    public int reverse(int x) {
        // 记录符号
        int sign = (x >= 0) ? 1 : -1;
        // 转换为正数处理
        long num = Math.abs((long)x);  // 用 long 避免溢出
        long reversed = 0;
        
        // 逐位反转
        while (num > 0) {
            reversed = reversed * 10 + num % 10;
            num /= 10;
            
            // 检查溢出
            if (reversed > Integer.MAX_VALUE || reversed < Integer.MIN_VALUE) {
                return 0;
            }
        }
        
        // 返回结果，带上原始符号
        return sign * (int)reversed;
    }
}
```

### 算法步骤详解
1. **符号处理**：
    - 用 `sign` 记录输入的正负号
    - 用 `Math.abs()` 取绝对值，转为正数处理

2. **反转过程**：
    - 使用 `num % 10` 获取最后一位数字
    - `reversed * 10 + num % 10` 将当前数字累加到结果
    - `num /= 10` 去掉已处理的最后一位
    - 循环直到 num 变为 0

3. **溢出检查**：
    - 使用 long 类型存储中间结果
    - 在每次累加后检查是否超出 Integer 的范围
    - 如果溢出，直接返回 0

4. **返回结果**：
    - 将最终结果乘以原始符号
    - 转换为 int 类型返回

### 时间与空间复杂度
- **时间复杂度**：O(log|x|) - 数字的位数决定了循环次数
- **空间复杂度**：O(1) - 只用了常数级额外空间

### 示例
1. 输入：x = 123
    - sign = 1
    - num = 123
    - reversed: 0 → 3 → 32 → 321
    - 输出：321

2. 输入：x = -123
    - sign = -1
    - num = 123
    - reversed: 0 → 3 → 32 → 321
    - 输出：-321

3. 输入：x = 120
    - sign = 1
    - num = 120
    - reversed: 0 → 0 → 2 → 21
    - 输出：21

4. 输入：x = 1534236469
    - 反转后超出 2³¹-1
    - 输出：0

### 注意事项
- 为什么用 long？因为直接用 int 在反转过程中可能溢出，无法正确判断
- Integer.MAX_VALUE = 2147483647
- Integer.MIN_VALUE = -2147483648

这个解法高效且易于理解，能够正确处理所有测试用例。