问题描述
给定一个 m x n 的二维网格 grid，其中 grid[i][j] 为 '1'（陆地）或 '0'（水）。岛屿由水平或垂直方向上相邻的 '1' 组成（对角线不算）。计算网格中岛屿的总数。

岛屿问题（Island Problem）是一类经典的算法问题，通常基于二维网格（grid），要求计算网格中“岛屿”的数量或相关属性。常见的岛屿问题包括：

1. **岛屿数量**（Number of Islands）：给定一个由 `'1'`（陆地）和 `'0'`（水）组成的二维网格，计算岛屿的数量。一个岛屿是由水平或垂直相连的 `'1'` 围成的区域。
2. **岛屿面积**（Max Area of Island）：计算最大岛屿的面积。
3. **岛屿周长**（Island Perimeter）：计算某个岛屿的周长。

这里我们以 **岛屿数量** 为例，详细分析其原理，提供图解，并给出 Java 实现。如果需要其他变种的实现，请告诉我！

---

### 问题描述
给定一个 `m x n` 的二维网格 `grid`，其中 `grid[i][j]` 为 `'1'`（陆地）或 `'0'`（水）。岛屿由水平或垂直方向上相邻的 `'1'` 组成（对角线不算）。计算网格中岛屿的总数。

**示例**：
```
输入：
[
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
解释：有 3 个岛屿（左上、右中、右下）。
```

---

### 原理分析

#### 核心思想
岛屿问题本质上是一个 **连通分量问题**，需要在二维网格中找到所有由 `'1'` 组成的连通区域。每个连通区域就是一个岛屿。常用的解决方法包括：

1. **深度优先搜索（DFS）**：
    - 从一个 `'1'` 开始，沿着水平和垂直方向递归探索所有相连的 `'1'`，并标记已访问的格子（通常将 `'1'` 改为 `'0'` 或其他标记）。
    - 每次发现一个新的 `'1'`，启动一次 DFS，计数加 1。
2. **广度优先搜索（BFS）**：
    - 类似 DFS，但使用队列逐层探索相邻的 `'1'`。
3. **并查集（Union-Find）**：
    - 将所有 `'1'` 视为节点，相邻的 `'1'` 合并到同一个集合，最后统计集合数量。

**DFS 是最直观且常用的方法**，因为它符合“沉没岛屿”的直觉：一旦发现一块陆地，就通过递归“淹没”整个岛屿。

#### 算法步骤
1. 遍历网格的每个格子 `(i, j)`：
    - 如果遇到 `'1'`，说明发现了一个新岛屿，岛屿计数加 1。
    - 从 `(i, j)` 启动 DFS，探索所有与之相连的 `'1'`。
2. 在 DFS 中：
    - 将当前格子标记为已访问（例如改为 `'0'`），避免重复计数。
    - 递归探索四个方向（上、下、左、右）的相邻格子。
    - 如果相邻格子越界、是 `'0'` 或已访问，则停止探索。
3. 继续遍历网格，直到所有格子处理完毕。
4. 返回岛屿计数。

#### 复杂度分析
- **时间复杂度**：`O(m * n)`，其中 `m` 是网格的行数，`n` 是列数。每个格子最多访问一次。
- **空间复杂度**：
    - DFS 使用递归栈，空间复杂度为 `O(m * n)`（最坏情况下，整个网格是陆地，递归深度达到 `m * n`）。
    - 如果直接修改网格（将 `'1'` 改为 `'0'`），无需额外空间，空间复杂度为 `O(1)`（不计递归栈）。

---

### 图解

以下是一个网格的岛屿数量问题图解，帮助理解 DFS 过程。

**输入网格**：
```
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
```

**步骤 1：初始化**
- 岛屿计数 `count = 0`。
- 遍历网格，找到第一个 `'1'`（例如 `(0, 0)`）。

**步骤 2：DFS 探索第一个岛屿**
- 从 `(0, 0)` 开始：
    - 标记 `(0, 0)` 为 `'0'`（已访问）。
    - 探索四个方向：
        - 上：越界，忽略。
        - 下：`(1, 0)` 是 `'1'`，递归。
        - 左：越界，忽略。
        - 右：`(0, 1)` 是 `'1'`，递归。
- 处理 `(1, 0)`：
    - 标记 `(1, 0)` 为 `'0'`。
    - 探索四个方向：
        - 上：`(0, 0)` 已访问，忽略。
        - 下：`(2, 0)` 是 `'0'`，忽略。
        - 左：越界，忽略。
        - 右：`(1, 1)` 是 `'1'`，递归。
- 处理 `(0, 1)` 和 `(1, 1)` 类似，最终整个左上岛屿被标记为 `'0'`：
```
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 1 1
```
- 岛屿计数 `count = 1`。

**步骤 3：继续遍历**
- 找到下一个 `'1'`（例如 `(2, 2)`）：
    - DFS 标记 `(2, 2)` 为 `'0'`。
    - 四个方向无 `'1'`，结束 DFS。
    - 网格变为：
```
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 1 1
```
- 计数 `count = 2`。

**步骤 4：最后一个岛屿**
- 找到 `(3, 3)`：
    - DFS 标记 `(3, 3)` 为 `'0'`。
    - 右边 `(3, 4)` 是 `'1'`，标记为 `'0'`。
    - 最终网格全为 `'0'`：
```
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
```
- 计数 `count = 3`。

**输出**：岛屿数量为 `3`。

---

### Java 实现

以下是基于 DFS 的 Java 代码实现：

```java
public class Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        
        int rows = grid.length;
        int cols = grid[0].length;
        int count = 0;
        
        // 遍历网格
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1') {
                    count++; // 发现新岛屿
                    dfs(grid, i, j); // 淹没整个岛屿
                }
            }
        }
        
        return count;
    }
    
    // DFS 淹没岛屿
    private void dfs(char[][] grid, int i, int j) {
        // 边界检查或非陆地格子
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != '1') {
            return;
        }
        
        // 标记当前格子为已访问
        grid[i][j] = '0';
        
        // 探索四个方向
        dfs(grid, i - 1, j); // 上
        dfs(grid, i + 1, j); // 下
        dfs(grid, i, j - 1); // 左
        dfs(grid, i, j + 1); // 右
    }
}
```

#### 代码说明
- **主函数 `numIslands`**：
    - 检查输入网格是否有效。
    - 遍历每个格子，遇到 `'1'` 时：
        - 岛屿计数加 1。
        - 调用 `dfs` 淹没整个岛屿（将所有相连的 `'1'` 改为 `'0'`）。
    - 返回最终计数。
- **辅助函数 `dfs`**：
    - 检查当前格子是否越界或不是 `'1'`，如果是则返回。
    - 将当前格子标记为 `'0'`。
    - 递归探索四个方向（上、下、左、右）。
- **输入处理**：
    - 空网格返回 `0`。
    - 修改网格本身作为访问标记，无需额外空间。

---

### 扩展：BFS 实现
如果需要 BFS 实现，可以使用队列来逐层探索相邻的 `'1'`。以下是 BFS 的 Java 代码：

```java
import java.util.LinkedList;
import java.util.Queue;

public class Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        
        int rows = grid.length;
        int cols = grid[0].length;
        int count = 0;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    bfs(grid, i, j);
                }
            }
        }
        
        return count;
    }
    
    private void bfs(char[][] grid, int i, int j) {
        int rows = grid.length;
        int cols = grid[0].length;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{i, j});
        grid[i][j] = '0'; // 标记为已访问
        
        // 四个方向：上、下、左、右
        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int x = curr[0], y = curr[1];
            
            // 探索四个方向
            for (int[] dir : directions) {
                int newX = x + dir[0];
                int newY = y + dir[1];
                
                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == '1') {
                    queue.offer(new int[]{newX, newY});
                    grid[newX][newY] = '0'; // 标记为已访问
                }
            }
        }
    }
}
```

#### BFS vs DFS
- **DFS**：递归实现，代码更简洁，适合快速淹没岛屿。空间复杂度依赖递归栈。
- **BFS**：使用队列，显式控制探索顺序，适合需要层次遍历的场景（例如计算最短路径）。空间复杂度依赖队列大小。

---

### 常见变种

2. **岛屿周长**：
    - 对于每个 `'1'`，检查四个方向是否为 `'0'` 或边界，每发现一个边界，周长加 1。
    - 示例代码：
      ```java
      public int islandPerimeter(int[][] grid) {
          int perimeter = 0;
          for (int i = 0; i < grid.length; i++) {
              for (int j = 0; j < grid[0].length; j++) {
                  if (grid[i][j] == 1) {
                      if (i == 0 || grid[i - 1][j] == 0) perimeter++; // 上
                      if (i == grid.length - 1 || grid[i + 1][j] == 0) perimeter++; // 下
                      if (j == 0 || grid[i][j - 1] == 0) perimeter++; // 左
                      if (j == grid[0].length - 1 || grid[i][j + 1] == 0) perimeter++; // 右
                  }
              }
          }
          return perimeter;
      }
      ```

3. **封闭岛屿数量**：
    - 岛屿不能触及网格边界。先将边界上的 `'1'` 淹没，再计算内部岛屿数量。

---

### 总结
- **原理**：岛屿问题通过 DFS 或 BFS 寻找连通分量，DFS 更简洁且常用于“淹没”岛屿。
- **复杂度**：时间 `O(m * n)`，空间 `O(m * n)`（DFS 递归栈）或 `O(1)`（修改原网格）。
- **图解**：通过逐步标记 `'1'` 为 `'0'`，清晰展示岛屿的发现和淹没过程。
- **代码**：提供了 DFS 和 BFS 实现，适用于大多数场景。
