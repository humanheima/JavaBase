我来重新详细讲解“找出数组中只出现一次的两个数字，其他数字都出现两次”的问题，包括思路、图解和 Java 实现，确保清晰易懂。

---

### 1. 问题描述
- **输入**：一个整数数组，例如 `[1, 2, 3, 2, 4, 1]`。
- **特点**：
    - 数组中有两个数字只出现一次（例如 `3` 和 `4`）。
    - 其他数字都出现两次（例如 `1` 和 `2`）。
- **输出**：找出这两个只出现一次的数字（例如 `[3, 4]`）。

---

### 2. 解题思路
我们利用**异或（XOR）**的性质来解决问题，因为它能高效处理成对抵消的情况。以下是逐步思路：

#### 核心性质：
- `A ^ A = 0`：相同数字异或为 0。
- `A ^ 0 = A`：任何数字与 0 异或为自己。
- 异或满足交换律和结合律。

#### 步骤：
1. **第一次异或：计算所有数字的异或结果**
    - 对整个数组异或，成对出现的数字会抵消为 0。
    - 结果是两个只出现一次的数字（记为 `x` 和 `y`）的异或值：`x ^ y`。
    - 因为 `x` 和 `y` 不同，所以 `x ^ y != 0`。

2. **找到区分位**
    - 在 `x ^ y` 的二进制表示中，找一个为 1 的位（通常用最低位）。
    - 这个位表示 `x` 和 `y` 在此位上不同（一个是 0，一个是 1）。
    - 用这个位作为分组依据。

3. **分组并第二次异或**
    - 根据区分位将数组分成两组：
        - 一组在此位为 0 的数字。
        - 一组在此位为 1 的数字。
    - `x` 和 `y` 会分到不同组，而成对的数字会分到同一组。
    - 对每组分别异或，得到 `x` 和 `y`。

---

### 3. 图解
以数组 `[1, 2, 3, 2, 4, 1]` 为例，目标是找出 `3` 和 `4`。

#### 步骤 1：第一次异或
```
数组: [1, 2, 3, 2, 4, 1]
二进制表示:
1 = 001
2 = 010
3 = 011
2 = 010
4 = 100
1 = 001
```
- 全部异或：`1 ^ 2 ^ 3 ^ 2 ^ 4 ^ 1`
- 成对抵消：`(1 ^ 1) ^ (2 ^ 2) ^ 3 ^ 4 = 0 ^ 0 ^ 3 ^ 4`
- 计算 `3 ^ 4`：
  ```
  011  (3)
^ 100  (4)
------
111  (7)
- 结果：`x ^ y = 7`。

#### 步骤 2：找到区分位
- `7` 的二进制是 `111`，最低位为 1。
- 用掩码 `1 (001)`（最低位）作为区分位。
  - 检查每个数字的最低位（与 `001` 按位与）。

#### 步骤 3：分组并异或
- **组 1**（最低位为 1，与 `1` 按位与不为 0）：
  - `1 (001)`、`3 (011)`、`1 (001)`。
  - 异或：`1 ^ 3 ^ 1 = 3`。
    ```
    001 ^ 011 = 010
    010 ^ 001 = 011  (3)
    ```
- **组 2**（最低位为 0，与 `1` 按位与为 0）：
  - `2 (010)`、`2 (010)`、`4 (100)`。
  - 异或：`2 ^ 2 ^ 4 = 4`。
    ```
    010 ^ 010 = 000
    000 ^ 100 = 100  (4)
    ```
- 结果：两个数字是 `3` 和 `4`。

---

### 4. Java 实现
以下是完整的代码实现：

```java
public class SingleNumberII {
    public static int[] findTwoSingleNumbers(int[] nums) {
        // 第一次异或：得到 x ^ y
        int xorResult = 0;
        for (int num : nums) {
            xorResult ^= num;
        }

        // 找到最低位为 1 的掩码
        int mask = xorResult & (-xorResult); // 提取最低位的 1

        // 分组并第二次异或
        int num1 = 0, num2 = 0;
        for (int num : nums) {
            if ((num & mask) == 0) {
                num1 ^= num; // 组 1：最低位为 0
            } else {
                num2 ^= num; // 组 2：最低位为 1
            }
        }

        return new int[]{num1, num2};
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 2, 4, 1};
        int[] result = findTwoSingleNumbers(nums);
        
        System.out.println("只出现一次的两个数字是: " + result[0] + " 和 " + result[1]);
    }
}
```

#### 输出：
```
只出现一次的两个数字是: 3 和 4
```

---

### 5. 代码解析
- **第一次异或**：
    - `xorResult` 计算所有数字的异或，结果是 `x ^ y`。
- **掩码计算**：
    - `xorResult & (-xorResult)` 是位运算技巧，提取最低位的 1。
    - 例如 `7 (111)`，`-7 = 001`（补码），`7 & 001 = 001`。
- **分组**：
    - `(num & mask) == 0`：最低位为 0 的组。
    - `(num & mask) != 0`：最低位为 1 的组。
- **第二次异或**：
    - 每组内成对数字抵消，剩下单次的数字。

#### 时间复杂度：
- O(n)，遍历数组两次。
#### 空间复杂度：
- O(1)，只用常数空间。

---

### 6. 验证
- 输入 `[5, 7, 5, 6, 6, 8]`：
    - 第一次异或：`5 ^ 7 ^ 5 ^ 6 ^ 6 ^ 8 = 7 ^ 8 = 15 (1111)`。
    - 掩码：`1`。
    - 组 1：`5, 7, 5` → `7`。
    - 组 2：`6, 6, 8` → `8`。
    - 结果：`[7, 8]`。

---

### 7. 总结
- **思路**：
    1. 第一次异或得到 `x ^ y`。
    2. 用最低位 1 分组。
    3. 第二次异或分离 `x` 和 `y`。
- **图解**：通过二进制逐位分析，清晰展示分组过程。
- **实现**：高效的位运算，时间复杂度 O(n)，空间复杂度 O(1)。

如果还有疑问或需要进一步扩展（例如三个只出现一次的数字），请告诉我！