好的，我将详细讲解快速排序的分区过程，并明确每个步骤中交换了哪两个值。以下以数组 `[5, 3, 8, 6, 2, 7, 1, 4]` 为例，选择最后一个元素 `4` 作为基准，逐步展示分区过程的图解。

---

### 图解：快速排序的分区过程
我们将详细展示 `partition` 方法的每一步，追踪数组的变化，并标注交换的元素。以下是代码中的分区逻辑：
- 基准（pivot）为 `4`（数组最后一个元素）。
- `i` 表示小于等于基准的区域边界，初始为 `low - 1`（即 -1）。
- `j` 从 `low`（即 0）遍历到 `high - 1`（即 6）。

#### 初始状态
```
数组: [5, 3, 8, 6, 2, 7, 1, 4]
索引:  0  1  2  3  4  5  6  7
pivot = 4, i = -1, j = 0
```

#### 步骤 1：j = 0，比较 arr[0] = 5 与 pivot = 4
- 5 > 4，不满足条件，不交换，`i` 不变。
```
数组: [5, 3, 8, 6, 2, 7, 1, 4]
       i=-1  j=0
```

#### 步骤 2：j = 1，比较 arr[1] = 3 与 pivot = 4
- 3 ≤ 4，满足条件，`i` 增至 0，交换 arr[i] 和 arr[j]。
- **交换**：arr[0] = 5 和 arr[1] = 3。
```
交换前: [5, 3, 8, 6, 2, 7, 1, 4]
交换后: [3, 5, 8, 6, 2, 7, 1, 4]
         i=0  j=1
```

#### 步骤 3：j = 2，比较 arr[2] = 8 与 pivot = 4
- 8 > 4，不满足条件，不交换。
```
数组: [3, 5, 8, 6, 2, 7, 1, 4]
       i=0     j=2
```

#### 步骤 4：j = 3，比较 arr[3] = 6 与 pivot = 4
- 6 > 4，不满足条件，不交换。
```
数组: [3, 5, 8, 6, 2, 7, 1, 4]
       i=0        j=3
```

#### 步骤 5：j = 4，比较 arr[4] = 2 与 pivot = 4
- 2 ≤ 4，满足条件，`i` 增至 1，交换 arr[i] 和 arr[j]。
- **交换**：arr[1] = 5 和 arr[4] = 2。
```
交换前: [3, 5, 8, 6, 2, 7, 1, 4]
交换后: [3, 2, 8, 6, 5, 7, 1, 4]
         i=1     j=4
```

#### 步骤 6：j = 5，比较 arr[5] = 7 与 pivot = 4
- 7 > 4，不满足条件，不交换。
```
数组: [3, 2, 8, 6, 5, 7, 1, 4]
         i=1        j=5
```

#### 步骤 7：j = 6，比较 arr[6] = 1 与 pivot = 4
- 1 ≤ 4，满足条件，`i` 增至 2，交换 arr[i] 和 arr[j]。
- **交换**：arr[2] = 8 和 arr[6] = 1。
```
交换前: [3, 2, 8, 6, 5, 7, 1, 4]
交换后: [3, 2, 1, 6, 5, 7, 8, 4]
         i=2     j=6
```

#### 步骤 8：j 遍历结束，将 pivot 放到正确位置
- `j` 已到达 `high - 1`（即 6），循环结束。
- 将基准 `4` 与 arr[i + 1] 交换，`i + 1 = 3`。
- **交换**：arr[3] = 6 和 arr[7] = 4。
```
交换前: [3, 2, 1, 6, 5, 7, 8, 4]
交换后: [3, 2, 1, 4, 5, 7, 8, 6]
         |<--小于4-->| pivot |<--大于4-->|
返回值: i + 1 = 3（基准位置）
```

#### 分区结果
- 分区后数组为 `[3, 2, 1, 4, 5, 7, 8, 6]`。
- 基准 `4` 在位置 3，左边 `[3, 2, 1]` 都 ≤ 4，右边 `[5, 7, 8, 6]` 都 > 4。

---

### 完整递归过程
#### 第一轮分区后
```
[3, 2, 1, 4, 5, 7, 8, 6]
```
- 递归左子数组 `[3, 2, 1]`（low = 0, high = 2）。
- 递归右子数组 `[5, 7, 8, 6]`（low = 4, high = 7）。

#### 左子数组 `[3, 2, 1]` 分区
- pivot = 1, i = -1, j 从 0 到 1。
1. j = 0, 3 > 1，无交换。
2. j = 1, 2 > 1，无交换。
3. 交换 pivot：arr[0] = 3 和 arr[2] = 1。
```
交换前: [3, 2, 1]
交换后: [1, 2, 3]
返回值: 0
```
- 左边 `[1]`，右边 `[2, 3]`，继续递归。

#### 右子数组 `[5, 7, 8, 6]` 分区
- pivot = 6, i = 3, j 从 4 到 6。
1. j = 4, 5 ≤ 6，i = 4，交换 arr[4] 和 arr[4]（不变）。
2. j = 5, 7 > 6，无交换。
3. j = 6, 8 > 6，无交换。
4. 交换 pivot：arr[5] = 7 和 arr[7] = 6。
```
交换前: [5, 7, 8, 6]
交换后: [5, 6, 8, 7]
返回值: 5
```
- 左边 `[5]`，右边 `[8, 7]`，继续递归。

#### 最终结果
经过多次递归分区，最终得到：
```
[1, 2, 3, 4, 5, 6, 7, 8]
```

---

### 总结交换过程
在第一次分区中，交换的元素对依次为：
1. `[5, 3]` → `[3, 5]`
2. `[5, 2]` → `[2, 5]`
3. `[8, 1]` → `[1, 8]`
4. `[6, 4]` → `[4, 6]`

后续递归中也会发生类似交换，直到数组完全排序。

如果您需要更直观的图像表示（例如流程图），请确认，我可以生成相关图片！