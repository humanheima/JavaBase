岛屿周长问题是 LeetCode 上的一道经典题目（LeetCode 463），要求计算一个二维网格中岛屿的周长。岛屿由 1 表示（陆地），周围被 0 表示（水）。周长是岛屿边界与水的接触边的总数。

https://leetcode.cn/problems/island-perimeter/description/

### 问题描述
- **输入**：一个 `m x n` 的二维网格，网格中的值是 0（水）或 1（陆地）。
- **输出**：岛屿的周长。
- **约束**：
    - 网格中恰好有一个岛屿（连通的 1 组成）。
    - 岛屿没有“湖”（岛屿内部没有水域）。
    - 网格被水完全包围。

### 算法思路与图解
岛屿周长的计算可以通过检查每个陆地格子（值为 1）的四条边（上、下、左、右）来实现。如果某条边与水（0）或网格边界相邻，则该边计入周长。

#### 图解步骤
假设有一个 4x4 网格：
```
0 1 0 0
1 1 1 0
0 1 0 0
0 0 0 0
```

1. **遍历网格**：
    - 扫描每个格子，找到值为 1 的陆地格子。
    - 对于每个陆地格子，检查其四个方向（上、下、左、右）。

2. **计算周长贡献**：
    - 对于一个陆地格子 (i, j)：
        - **上边**：如果 `i == 0`（网格上边界）或 `grid[i-1][j] == 0`（上方是水），则周长 +1。
        - **下边**：如果 `i == m-1`（网格下边界）或 `grid[i+1][j] == 0`（下方是水），则周长 +1。
        - **左边**：如果 `j == 0`（网格左边界）或 `grid[i][j-1] == 0`（左方是水），则周长 +1。
        - **右边**：如果 `j == n-1`（网格右边界）或 `grid[i][j+1] == 0`（右方是水），则周长 +1。

3. **可视化示例**：
   对于网格中的陆地格子 (1, 1)：
   ```
   0 1 0 0
   1 [1] 1 0
   0 1 0 0
   0 0 0 0
   ```
    - 上：`grid[0][1] = 1`（陆地），不计入周长。
    - 下：`grid[2][1] = 1`（陆地），不计入周长。
    - 左：`grid[1][0] = 1`（陆地），不计入周长。
    - 右：`grid[1][2] = 1`（陆地），不计入周长。
    - 结果：此格子贡献周长为 0。

   对于格子 (0, 1)：
   ```
   0 [1] 0 0
   1 1 1 0
   0 1 0 0
   0 0 0 0
   ```
    - 上：`i == 0`（上边界），周长 +1。
    - 下：`grid[1][1] = 1`（陆地），不计。
    - 左：`grid[0][0] = 0`（水），周长 +1。
    - 右：`grid[0][2] = 0`（水），周长 +1。
    - 结果：此格子贡献周长为 3。

4. **汇总**：
    - 对所有陆地格子重复上述步骤，累加每个格子的周长贡献。

#### 算法复杂度
- **时间复杂度**：O(m * n)，需要遍历整个网格。
- **空间复杂度**：O(1)，仅使用常数额外空间。

### Java 实现
以下是基于上述思路的 Java 代码：

```java
public class Solution {
    public int islandPerimeter(int[][] grid) {
        int perimeter = 0;
        int m = grid.length; // 行数
        int n = grid[0].length; // 列数

        // 遍历每个格子
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) { // 找到陆地格子
                    // 检查上边
                    if (i == 0 || grid[i - 1][j] == 0) {
                        perimeter++;
                    }
                    // 检查下边
                    if (i == m - 1 || grid[i + 1][j] == 0) {
                        perimeter++;
                    }
                    // 检查左边
                    if (j == 0 || grid[i][j - 1] == 0) {
                        perimeter++;
                    }
                    // 检查右边
                    if (j == n - 1 || grid[i][j + 1] == 0) {
                        perimeter++;
                    }
                }
            }
        }

        return perimeter;
    }

    // 测试代码
    public static void main(String[] args) {
        Solution rotatedArraySearch = new Solution();
        int[][] grid = {
            {0, 1, 0, 0},
            {1, 1, 1, 0},
            {0, 1, 0, 0},
            {0, 0, 0, 0}
        };
        System.out.println("岛屿周长: " + rotatedArraySearch.islandPerimeter(grid)); // 输出 16
    }
}
```

### 代码说明
1. **遍历网格**：使用双重循环遍历每个格子，检查是否为陆地（`grid[i][j] == 1`）。
2. **边界检查**：
    - 对于每个方向，使用逻辑或 (`||`) 检查是否是网格边界或水格子。
    - 如果条件满足，周长加 1。
3. **测试用例**：
    - 示例网格的周长计算结果为 16：
        - 格子 (0,1) 贡献 3。
        - 格子 (1,0) 贡献 2。
        - 格子 (1,1) 贡献 0。
        - 格子 (1,2) 贡献 3。
        - 格子 (2,1) 贡献 3。
        - 总计：3 + 2 + 0 + 3 + 3 = 16。

### 优化与扩展
- **替代方法**：可以使用 DFS 或 BFS 遍历岛屿，但由于只需要周长，迭代方法更简单且高效。
- **扩展问题**：如果有多个岛屿，可以稍作修改，依然对每个陆地格子计算周长贡献。

如果需要进一步解释或可视化代码执行过程，请告诉我！