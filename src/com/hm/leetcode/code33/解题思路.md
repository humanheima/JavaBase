### 问题分析

这道题目要求我们在**旋转排序数组**中查找目标值 `target` 的下标，时间复杂度必须为 **O(log n)**，这提示我们需要使用**二分查找**来解决问题。旋转排序数组是指一个原本升序的数组在某个点 `k` 处被旋转，例如 `[0,1,2,4,5,6,7]` 旋转后可能变成 `[4,5,6,7,0,1,2]`。我们的目标是找到 `target` 在旋转后的数组中的下标，如果不存在则返回 `-1`。

#### 算法解析
1. **问题特点**：
    - 数组是旋转后的排序数组，意味着数组整体不再是完全升序的，但可以分为两个**有序子数组**（例如 `[4,5,6,7]` 和 `[0,1,2]` 都是升序的）。
    - 时间复杂度要求为 **O(log n)**，因此不能使用线性扫描，必须利用二分查找。
    - 旋转点 `k` 未知，但可以通过二分查找的性质判断旋转点的位置。

2. **二分查找的思路**：
    - 由于数组是旋转后的排序数组，我们可以用二分查找来定位目标值，但需要处理旋转带来的部分有序性。
    - 每次二分时，数组被分成两部分，其中至少有一部分是**有序的**。我们可以根据有序部分判断 `target` 是否在其中，并据此缩小搜索范围。
    - 关键在于如何判断哪一部分是有序的，以及 `target` 是否在有序部分中。

3. **算法步骤**：
    - 初始化两个指针：`left`（指向数组开头）和 `right`（指向数组末尾）。
    - 每次循环：
        - 计算中间点 `mid`。
        - 判断 `mid` 所在的子数组是否有序：
            - 如果 `nums[mid] >= nums[left]`，说明 `left` 到 `mid` 是有序的。
            - 否则，`mid` 到 `right` 是有序的。
        - 根据有序部分的范围，检查 `target` 是否在该范围内：
            - 如果在有序部分，缩小到该部分继续搜索。
            - 如果不在有序部分，缩小到另一部分继续搜索。
        - 如果 `nums[mid] == target`，直接返回 `mid`。
    - 如果循环结束仍未找到，返回 `-1`。

4. **边界条件**：
    - 数组可能未旋转（即 `k = 0`），此时整个数组是有序的。
    - 数组可能只有一个元素，需特殊处理。
    - 目标值可能不存在于数组中，返回 `-1`。

5. **时间复杂度**：
    - 每次二分将搜索范围缩小一半，因此时间复杂度为 **O(log n)**。
    - 空间复杂度为 **O(1)**，只使用了常数级额外空间。

---

### Java 实现

以下是基于上述分析的 Java 代码实现：

```java
public class Solution {
    public int search(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            }
            
            // 判断左半部分是否有序
            if (nums[mid] >= nums[left]) {
                // 左半部分有序，检查 target 是否在 [left, mid] 范围内
                if (target >= nums[left] && target < nums[mid]) {
                    right = mid - 1; // 在左半部分搜索
                } else {
                    left = mid + 1; // 在右半部分搜索
                }
            } else {
                // 右半部分有序，检查 target 是否在 [mid, right] 范围内
                if (target > nums[mid] && target <= nums[right]) {
                    left = mid + 1; // 在右半部分搜索
                } else {
                    right = mid - 1; // 在左半部分搜索
                }
            }
        }
        
        return -1; // 未找到目标值
    }
}
```

---

### 代码解析

1. **输入检查**：
    - 如果数组为空或 `null`，直接返回 `-1`。

2. **二分查找循环**：
    - 使用 `left` 和 `right` 指针定义当前搜索范围。
    - 计算中间点 `mid`，使用 `left + (right - left) / 2` 避免整数溢出。
    - 如果 `nums[mid] == target`，返回 `mid`。

3. **判断有序部分**：
    - 如果 `nums[mid] >= nums[left]`，说明 `left` 到 `mid` 是有序的：
        - 检查 `target` 是否在 `[nums[left], nums[mid])` 范围内。
        - 如果是，搜索左半部分（`right = mid - 1`）。
        - 否则，搜索右半部分（`left = mid + 1`）。
    - 否则，`mid` 到 `right` 是有序的：
        - 检查 `target` 是否在 `(nums[mid], nums[right]]` 范围内。
        - 如果是，搜索右半部分（`left = mid + 1`）。
        - 否则，搜索左半部分（`right = mid - 1`）。

4. **循环终止**：
    - 当 `left > right` 时，说明搜索范围为空，未找到目标值，返回 `-1`。

---

### 示例运行

#### 示例 1
输入：`nums = [4,5,6,7,0,1,2], target = 0`
- 初始：`left = 0, right = 6`
- 第1次：`mid = 3, nums[mid] = 7`
    - `nums[mid] >= nums[left]`，左半部分 `[4,5,6,7]` 有序。
    - `target = 0` 不在 `[4,7)`，搜索右半部分：`left = 4`。
- 第2次：`mid = 5, nums[mid] = 1`
    - `nums[mid] < nums[left]`，右半部分 `[1,2]` 有序。
    - `target = 0` 不在 `(1,2]`，搜索左半部分：`right = 4`。
- 第3次：`mid = 4, nums[mid] = 0`
    - `nums[mid] == target`，返回 `4`。
      输出：`4`

#### 示例 2
输入：`nums = [4,5,6,7,0,1,2], target = 3`
- 经过多次二分，最终 `left > right`，未找到目标值。
  输出：`-1`

#### 示例 3
输入：`nums = [1], target = 0`
- 初始：`mid = 0, nums[mid] = 1`
- `nums[mid] != target`，且 `left == right`，循环结束。
  输出：`-1`

---

### 复杂度分析
- **时间复杂度**：O(log n)，每次二分将搜索范围减半。
- **空间复杂度**：O(1)，只使用了常数级变量（`left`, `right`, `mid`）。

---

### 总结
该算法通过二分查找巧妙地处理了旋转排序数组的特性，利用数组的局部有序性在 O(log n) 时间内找到目标值。代码逻辑清晰，边界处理完善，适用于所有测试用例。