>11. 盛最多水的容器

>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明：你不能倾斜容器。

这是一个经典的双指针问题，称为“盛最多水的容器”。以下是对问题的解析以及使用 Java 实现的解决方案。

---

### 算法解析

**问题描述**：
- 给定一个数组 `height`，其中 `height[i]` 表示第 `i` 条垂线的高度。
- 需要找到两条垂线，与 x 轴构成的容器能够盛放最多的水。
- 容器的水量由以下公式计算：
    - 面积 = 两条垂线之间的距离 × 两条垂线中较短的高度
    - 即：`area = (j - i) * min(height[i], height[j])`，其中 `i` 和 `j` 是两条垂线的索引。

**关键点**：
- 容器的水量取决于：
    - 两条垂线的距离（即 `j - i`）。
    - 两条垂线中较短的高度（因为水会从较低的一侧溢出）。
- 目标是最大化面积。

**方法：双指针法**：
- 使用两个指针 `left` 和 `right`，分别从数组的两端开始。
- 计算当前 `left` 和 `right` 构成的容器的水量。
- 移动高度较短的指针（向内移动），因为：
    - 水量受限于较短的边，移动较短边可能找到更高的高度，从而增加水量。
    - 移动较长边只会减少宽度（因为距离变小），且高度不会超过当前较短边，因此不可能增加水量。
- 重复上述步骤，直到 `left` 和 `right` 相遇。
- 在每次计算中，记录最大水量。

**时间复杂度**：
- 双指针每次移动一个指针，遍历整个数组需要 O(n) 时间。
- 空间复杂度为 O(1)，仅使用常数额外空间。

---

### Java 实现

```java
public class Solution {
    public int maxArea(int[] height) {
        int left = 0; // 左指针
        int right = height.length - 1; // 右指针
        int maxArea = 0; // 最大水量
        
        while (left < right) {
            // 计算当前容器的水量
            int width = right - left;
            int minHeight = Math.min(height[left], height[right]);
            int area = width * minHeight;
            
            // 更新最大水量
            maxArea = Math.max(maxArea, area);
            
            // 移动较短边的指针
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxArea;
    }
}
```

---

### 代码说明

1. **初始化**：
    - `left` 指向数组开头（索引 0）。
    - `right` 指向数组末尾（索引 `height.length - 1`）。
    - `maxArea` 用于记录最大水量，初始为 0。

2. **循环**：
    - 当 `left < right` 时，继续计算：
        - 宽度 `width = right - left`。
        - 高度取 `height[left]` 和 `height[right]` 的较小值。
        - 当前水量 `area = width * minHeight`。
        - 更新 `maxArea` 如果当前 `area` 更大。

3. **指针移动**：
    - 如果 `height[left] < height[right]`，移动 `left`（左指针右移）。
    - 否则，移动 `right`（右指针左移）。
    - 这样可以尝试寻找更高的高度，以增加水量。

4. **返回结果**：
    - 当 `left` 和 `right` 相遇时，返回 `maxArea`。

---

### 示例

**输入**：`height = [1,8,6,2,5,4,8,3,7]`
- 初始：`left = 0`, `right = 8`，计算面积 = `min(1, 7) * 8 = 1 * 8 = 8`。
- 移动 `left`（因为 `height[0] = 1 < height[8] = 7`）。
- 继续计算，直到找到最大面积 `49`（选择 `height[1] = 8` 和 `height[8] = 7`，宽度为 7，面积 = `7 * min(8, 7) = 49`）。
- **输出**：`49`

**输入**：`height = [1,1]`
- 初始：`left = 0`, `right = 1`，面积 = `min(1, 1) * 1 = 1`。
- 移动后 `left` 和 `right` 相遇，结束。
- **输出**：`1`

---

### 复杂度分析
- **时间复杂度**：O(n)，其中 n 是数组长度，双指针遍历一次数组。
- **空间复杂度**：O(1)，仅使用常数额外空间。

---

### 为什么双指针有效？
- 初始时，宽度是最大的（`left = 0`, `right = n-1`）。
- 每次移动较短边的指针，尝试找到更高的高度，同时牺牲宽度。
- 由于水量受限于较短边，移动较长边不会增加水量，因此只移动较短边是合理的。
- 双指针保证了所有可能的线对都会被考虑（直接或间接），不会错过最大水量。

---

如果你有其他问题或需要更详细的解释，请告诉我！